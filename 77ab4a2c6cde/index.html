<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux源码阅读之内核启动 | Noal</title><meta name="author" content="orz"><meta name="copyright" content="orz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="体系: Armv7处理器: imx6ul架构: Cortex-a7内核版本: 5.4.70  总览内核启动&amp;emsp;&amp;emsp;arm架构处理器启动linux内核需要满足以下条件：  CPU寄存器设置 R0寄存器为0 R1寄存器保存machine id R2寄存器保存启动参数在内存中的起始地址   CPU模式设置 禁用所有的中断 进入SVC超级模式   缓存、MMU 关闭MMU I Cache">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux源码阅读之内核启动">
<meta property="og:url" content="https://www.m5xhsy.wiki/77ab4a2c6cde/index.html">
<meta property="og:site_name" content="Noal">
<meta property="og:description" content="体系: Armv7处理器: imx6ul架构: Cortex-a7内核版本: 5.4.70  总览内核启动&amp;emsp;&amp;emsp;arm架构处理器启动linux内核需要满足以下条件：  CPU寄存器设置 R0寄存器为0 R1寄存器保存machine id R2寄存器保存启动参数在内存中的起始地址   CPU模式设置 禁用所有的中断 进入SVC超级模式   缓存、MMU 关闭MMU I Cache">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.m5xhsy.wiki/statics/img/cover/default.webp">
<meta property="article:published_time" content="2023-03-24T11:53:52.000Z">
<meta property="article:modified_time" content="2023-03-24T11:53:52.000Z">
<meta property="article:author" content="orz">
<meta property="article:tag" content="Linux源码阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.m5xhsy.wiki/statics/img/cover/default.webp"><link rel="shortcut icon" href="/statics/img/core/avatar.webp"><link rel="canonical" href="https://www.m5xhsy.wiki/77ab4a2c6cde/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: orz","link":"链接: ","source":"来源: Noal","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux源码阅读之内核启动',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-24 19:53:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/statics/css/style.css"><link rel="stylesheet" href="/statics/css/universe.css"><link rel="stylesheet" href="/statics/css/right_button.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/statics/img/core/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/statics/img/top/default.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Noal</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux源码阅读之内核启动</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-24T11:53:52.000Z" title="发表于 2023-03-24 19:53:52">2023-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-24T11:53:52.000Z" title="更新于 2023-03-24 19:53:52">2023-03-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux源码阅读之内核启动"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>体系: Armv7<br>处理器: imx6ul<br>架构: Cortex-a7<br>内核版本: 5.4.70</p>
</blockquote>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><h2 id="内核启动"><a href="#内核启动" class="headerlink" title="内核启动"></a>内核启动</h2><p>&emsp;&emsp;<strong>arm架构处理器启动linux内核需要满足以下条件：</strong></p>
<ol>
<li>CPU寄存器设置<ul>
<li>R0寄存器为0</li>
<li>R1寄存器保存machine id</li>
<li>R2寄存器保存启动参数在内存中的起始地址</li>
</ul>
</li>
<li>CPU模式设置<ul>
<li>禁用所有的中断</li>
<li>进入SVC超级模式</li>
</ul>
</li>
<li>缓存、MMU<ul>
<li>关闭MMU</li>
<li>I Cache可以打开，也可以关闭</li>
<li>D Cache必须关闭，且不能有脏数据</li>
</ul>
</li>
<li>设备<ul>
<li>DMA设备需要停止工作</li>
</ul>
</li>
<li>bootloader跳转到内核第一条指令处</li>
</ol>
<p>&emsp;&emsp;首先分析的是<code>arch/arm/kernel/vmlinux.lds</code>文件，该文件是由同级目录下<code>vmlinux.lds.S</code>编译来的，它定义了内核镜像的布局和链接规则，各个段的起始地址、大小、对齐方式等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(stext)</span><br><span class="line">jiffies = jiffies_64;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> /DISCARD/ : &#123;</span><br><span class="line">  *(.ARM.exidx.exit.text) *(.ARM.extab.exit.text) *(.ARM.exidx.text.exit) *(.ARM.extab.text.exit) *(.exitcall.exit) *(.discard) *(.discard.*)</span><br><span class="line"> &#125;</span><br><span class="line">  . = ((0xC0000000)) + 0x00008000;</span><br><span class="line"> .head.text : &#123;</span><br><span class="line">  _text = .;</span><br><span class="line">  KEEP(*(.head.text))</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(1&lt;&lt;20);</span><br><span class="line"></span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里只截取的一部分，脚本中各个段的定义如下：</p>
<ul>
<li><code>.text</code>: 内核代码段，包括内核的函数、中断服务程序和系统调用的处理函数；</li>
<li><code>.rodata</code>: 只读数据段，包括内核中使用的常量和字符串； </li>
<li><code>.data</code>: 可写数据段，包括内核中全局变量和静态变量；</li>
<li><code>.bss</code>: 未初始化的数据段，包括内核中未初始化的全局变量和静态变量等；</li>
<li><code>.init.text</code>: 内核初始化代码段，包括内核的初始化函数等；</li>
<li><code>.init.data</code>: 内核初始化数据段，包括内核初始化过程中使用的全局变量和静态变量等；</li>
<li><code>.exit.text</code>: 内核退出代码段，包括内核的退出函数等；</li>
<li><code>.exit.data</code>: 内核退出数据段，包括内核退出过程中使用的全局变量和静态变量等；</li>
<li><code>.notes</code>: 内核注释段，包括内核版本信息、编译时间、编译器版本等；</li>
</ul>
<p>&emsp;&emsp;同时<code>vmlinux.lds</code>文件中还定义了编译器的其他符号，例如<code>. = ((0xC0000000)) + 0x00008000;</code>可以设置当前位置的地址、<code>_text = .</code>表示<code>_text</code>符号代表当前的位置(也就是<code>_text</code>变量保存当前地址)、<code>. = ALIGN(1&lt;&lt;20);</code>表示对当前位置进行对齐、<code>ENTRY(stext)</code>表示内核的入口函数为<code>stext</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kernel startup entry point.</span></span><br><span class="line"><span class="comment"> * ---------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is normally called from the decompressor code.  The requirements</span></span><br><span class="line"><span class="comment"> * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,</span></span><br><span class="line"><span class="comment"> * r1 = machine nr, r2 = atags or dtb pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This code is mostly position independent, so if you link the kernel at</span></span><br><span class="line"><span class="comment"> * 0xc0008000, you call this at __pa(0xc0008000).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See linux/arch/arm/tools/mach-types for the complete list of machine</span></span><br><span class="line"><span class="comment"> * numbers for r1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We&#x27;re trying to keep crap to a minimum; DO NOT add any machine specific</span></span><br><span class="line"><span class="comment"> * crap here - that&#x27;s what the boot loader (or in extreme, well justified</span></span><br><span class="line"><span class="comment"> * circumstances, zImage) is for.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	.arm</span><br><span class="line"></span><br><span class="line">	__HEAD</span><br><span class="line"><span class="title function_">ENTRY</span><span class="params">(stext)</span></span><br><span class="line"> <span class="title function_">ARM_BE8</span><span class="params">(setend	be )</span>			@ ensure we are in BE8 mode</span><br><span class="line"></span><br><span class="line"> <span class="title function_">THUMB</span><span class="params">(	badr	r9, <span class="number">1f</span>		)</span>	@ Kernel is always entered in ARM.</span><br><span class="line"> <span class="title function_">THUMB</span><span class="params">(	bx	r9		)</span>	@ If this is a Thumb-2 kernel,</span><br><span class="line"> <span class="title function_">THUMB</span><span class="params">(	.thumb			)</span>	@ <span class="keyword">switch</span> to Thumb now.</span><br><span class="line"> <span class="title function_">THUMB</span><span class="params">(<span class="number">1</span>:			)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_VIRT_EXT</span></span><br><span class="line">	bl	__hyp_stub_install</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	@ ensure svc mode and all interrupts masked</span><br><span class="line">	safe_svcmode_maskall r9</span><br><span class="line"></span><br><span class="line">	mrc	p15, 0, r9, c0, c0		@ get processor id</span><br><span class="line">	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid</span><br><span class="line">	movs	r10, r5				@ invalid processor (r5=<span class="number">0</span>)?</span><br><span class="line"> THUMB( it	eq )		@ force fixup-able <span class="type">long</span> branch encoding</span><br><span class="line">	beq	__error_p			@ yes, error <span class="string">&#x27;p&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_LPAE</span></span><br><span class="line">	mrc	p15, <span class="number">0</span>, r3, c0, c1, <span class="number">4</span>		@ read ID_MMFR0</span><br><span class="line">	and	r3, r3, #<span class="number">0xf</span>			@ extract VMSA support</span><br><span class="line">	cmp	r3, #<span class="number">5</span>				@ <span class="type">long</span>-descriptor translation table format?</span><br><span class="line"> THUMB( it	lo )				@ force fixup-able <span class="type">long</span> branch encoding</span><br><span class="line">	blo	__error_lpae			@ only classic page table format</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_XIP_KERNEL</span></span><br><span class="line">	adr	r3, <span class="number">2f</span></span><br><span class="line">	ldmia	r3, &#123;r4, r8&#125;</span><br><span class="line">	sub	r4, r3, r4			@ (PHYS_OFFSET - PAGE_OFFSET)</span><br><span class="line">	add	r8, r8, r4			@ PHYS_OFFSET</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this <span class="keyword">case</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * r1 = machine no, r2 = atags or dtb,</span></span><br><span class="line"><span class="comment">	 * r8 = phys_offset, r9 = cpuid, r10 = procinfo</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bl	__vet_atags</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP_ON_UP </span></span><br><span class="line">	bl	__fixup_smp</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_PATCH_PHYS_VIRT</span></span><br><span class="line">	bl	__fixup_pv_table</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	bl	__create_page_tables</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The following calls CPU specific code in a position independent</span></span><br><span class="line"><span class="comment">	 * manner.  See arch/arm/mm/proc-*.S for details.  r10 = base of</span></span><br><span class="line"><span class="comment">	 * xxx_proc_info structure selected by __lookup_processor_type</span></span><br><span class="line"><span class="comment">	 * above.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The processor init function will be called with:</span></span><br><span class="line"><span class="comment">	 *  r1 - machine type</span></span><br><span class="line"><span class="comment">	 *  r2 - boot data (atags/dt) pointer</span></span><br><span class="line"><span class="comment">	 *  r4 - translation table base (low word)</span></span><br><span class="line"><span class="comment">	 *  r5 - translation table base (high word, if LPAE)</span></span><br><span class="line"><span class="comment">	 *  r8 - translation table base 1 (pfn if LPAE)</span></span><br><span class="line"><span class="comment">	 *  r9 - cpuid</span></span><br><span class="line"><span class="comment">	 *  r13 - virtual address for __enable_mmu -&gt; __turn_mmu_on</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * On return, the CPU will be ready for the MMU to be turned on,</span></span><br><span class="line"><span class="comment">	 * r0 will hold the CPU control register value, r1, r2, r4, and</span></span><br><span class="line"><span class="comment">	 * r9 will be preserved.  r5 will also be preserved if LPAE.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ldr	r13, =__mmap_switched		@ address to jump to after</span><br><span class="line">						@ mmu has been enabled</span><br><span class="line">	badr	lr, <span class="number">1f</span>				@ <span class="keyword">return</span> (PIC) address</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_LPAE</span></span><br><span class="line">	mov	r5, #<span class="number">0</span>				@ high TTBR0</span><br><span class="line">	mov	r8, r4, lsr #<span class="number">12</span>			@ TTBR1 is swapper_pg_dir pfn</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	mov	r8, r4				@ <span class="built_in">set</span> TTBR1 to swapper_pg_dir</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	ldr	r12, [r10, #PROCINFO_INITFUNC]</span><br><span class="line">	add	r12, r12, r10</span><br><span class="line">	ret	r12</span><br><span class="line"><span class="number">1</span>:	b	__enable_mmu</span><br><span class="line">ENDPROC(stext)</span><br><span class="line">	.ltorg</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_XIP_KERNEL</span></span><br><span class="line"><span class="number">2</span>:	.<span class="type">long</span>	.</span><br><span class="line">	.<span class="type">long</span>	PAGE_OFFSET</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>__hyp_stub_install</code>函数是ARM架构下KVM虚拟化的一个函数，定义在<code>arch/arm/kvm/hyp-stub.S</code>文件中，该函数的主要作用是将KVM虚拟化的处理器切换到Hypervisor模式，以便在Hypervisor模式下运行虚拟机；</li>
<li><code>safe_svcmode_maskall</code>函数用于使能SVC模式并关闭所有中断；</li>
<li><code>mrc    p15, 0, r9, c0, c0</code>从CP15寄存器中获取处理器ID到R9寄存器中；</li>
<li><code>__lookup_processor_type</code>函数用于检查当前系统是否支持该CPU，如果支持就获取<code>procinfo</code>, <code>__look_processor_type</code>函数则通过R9寄存器中的处理器ID获取到<code>procinfo</code>地址并保存到R5寄存器中；</li>
<li><code>movs    r10, r5</code>将R5寄存器中的<code>procinfo</code>地址保存到R10寄存器中，这里<code>movs</code>指令是在<code>mov</code>指令的基础上进行了条件判断，如果R5寄存器中的值为0，则表示没找到<code>procinfo</code>，执行<code>beq __error_p</code>函数处理错误；</li>
<li><code>__vet_atags</code>用于验证dtb的有效性；</li>
<li><code>_create_page_tables</code>主要用于创建临时内核页表；</li>
<li><code>ldr    r13, =__mmap_switched</code>将标号读取到R13寄存器中，后续使能MMU后会执行该函数；</li>
<li><code>badr    lr, 1f</code>这里的<code>1f</code>是一个标号，不是指<code>0x1f</code>,，该指令计算出标号<code>1:</code>处的地址保存到LR寄存器中；</li>
<li><code>ldr    r12, [r10, #PROCINFO_INITFUNC]</code>指令将R10寄存器中保存的<code>procinfo</code>基地址偏移<code>PROCINFO_INITFUNC</code>后地址的值读取到R12寄存器；<code>PROCINFO_INITFUNC</code>定义在<code>arch/arm/kernel/asm-offsets.c</code>文件中(<code>DEFINE(PROCINFO_INITFUNC,    offsetof(struct proc_info_list, __cpu_flush));</code>)，所以R12寄存器中保存的是<code>__cpu_flash</code>的值，这个值表示CPU设置函数相对于<code>procinfo</code>基地址的偏移地址，后面<code>add    r12, r12, r10</code>将<code>procinfo</code>地址加上偏移地址并保存到R12寄存器中，最后<code>ret r12</code>跳转到CPU设置函数，因为前面保存了<code>1:</code>的标号到LR寄存器，执行完CPU设置后会跳转到<code>1:</code>标号继续执行；</li>
<li><code>1:    b    __enable_mmu</code>指令会使能MMU，然后执行R13寄存器中的<code>__mmap_switched</code>函数；</li>
</ul>
<h2 id="进入SVC和关闭中断"><a href="#进入SVC和关闭中断" class="headerlink" title="进入SVC和关闭中断"></a>进入SVC和关闭中断</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper macro to enter SVC mode cleanly and mask interrupts. reg is</span></span><br><span class="line"><span class="comment"> * a scratch register for the macro to overwrite.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro is intended for forcing the CPU into SVC mode at boot time.</span></span><br><span class="line"><span class="comment"> * you cannot return to the original mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.macro safe_svcmode_maskall reg:req</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LINUX_ARM_ARCH__ &gt;= 6 &amp;&amp; !defined(CONFIG_CPU_V7M)</span></span><br><span class="line">	mrs	\reg , cpsr</span><br><span class="line">	eor	\reg, \reg, #HYP_MODE</span><br><span class="line">	tst	\reg, #MODE_MASK</span><br><span class="line">	bic	\reg , \reg , #MODE_MASK</span><br><span class="line">	orr	\reg , \reg , #PSR_I_BIT | PSR_F_BIT | SVC_MODE</span><br><span class="line"><span class="title function_">THUMB</span><span class="params">(	orr	\reg , \reg , #PSR_T_BIT	)</span></span><br><span class="line">	bne	1f</span><br><span class="line">	orr	\reg, \reg, #PSR_A_BIT</span><br><span class="line">	badr	lr, 2f</span><br><span class="line">	msr	spsr_cxsf, \reg</span><br><span class="line">	__<span class="title function_">MSR_ELR_HYP</span><span class="params">(<span class="number">14</span>)</span></span><br><span class="line">	__ERET</span><br><span class="line">1:	msr	cpsr_c, \reg</span><br><span class="line">2:</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * workaround for possibly broken pre-v6 hardware</span></span><br><span class="line"><span class="comment"> * (akita, Sharp Zaurus C-1000, PXA270-based)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	setmode	PSR_F_BIT | PSR_I_BIT | SVC_MODE, \reg</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<h2 id="处理器相关操作"><a href="#处理器相关操作" class="headerlink" title="处理器相关操作"></a>处理器相关操作</h2><h3 id="处理器信息保存"><a href="#处理器信息保存" class="headerlink" title="处理器信息保存"></a>处理器信息保存</h3><p>&emsp;&emsp;前面分析<code>__lookup_processor_type</code>函数是通过CP15协处理器中的处理器ID获取处理器信息<code>procinfo</code>，每种处理器都有一个对应的<code>procinfo</code>；Linux内核将每一种处理器都抽象成一个<code>struct proc_info_list</code>结构体，该结构体定义在<code>arch/arm/include/asm/procinfo.h</code>文件中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cpu_val;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cpu_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		__cpu_mm_mmu_flags;	<span class="comment">/* used by head.S */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		__cpu_io_mmu_flags;	<span class="comment">/* used by head.S */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		__cpu_flush;		<span class="comment">/* used by head.S */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*arch_name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*elf_name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		elf_hwcap;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*cpu_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">processor</span>	*<span class="title">proc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_tlb_fns</span>	*<span class="title">tlb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_user_fns</span>	*<span class="title">user</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_cache_fns</span>	*<span class="title">cache</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cpu_val</code>: CPU对应的硬件ID号；</li>
<li><code>cpu_mask</code>: CPU硬件ID号的掩码；</li>
<li><code>__cpu_mm_mmu_flags</code>: 临时页表映射的内核空间的MMU标识；</li>
<li><code>__cpu_io_mmu_flags</code>: IO映射区的MMU标识；</li>
<li><code>__cpu_flush</code>: cpu setup函数相对<code>procinfo</code>的偏移地址；</li>
</ul>
<p>&emsp;&emsp;通过链接脚本文件可以知道所有的<code>procinfo</code>信息都会保存在<code>.init.proc.info</code>段中，如<code>vmlinux.lds.S</code>和<code>vmlinux.lds.h</code>文件所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define PROC_INFO							\</span><br><span class="line">		. = ALIGN(4);						\</span><br><span class="line">		__proc_info_begin = .;				\</span><br><span class="line">		*(.proc.info.init)					\</span><br><span class="line">		__proc_info_end = .;</span><br><span class="line"></span><br><span class="line">.init.proc.info : &#123;</span><br><span class="line">	ARM_CPU_DISCARD(PROC_INFO)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译内核后，可以在<code>System.map</code>文件中找到<code>__proc_info_begin</code>和<code>__proc_info_end</code>的符号，中间部分就是<code>.init.proc.info</code>段的函数：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">c0c70d60 T __proc_info_begin</span><br><span class="line">c0c70d60 t __v6_proc_info</span><br><span class="line">c0c70d94 t __v7_ca5mp_proc_info</span><br><span class="line">c0c70dc8 t __v7_ca9mp_proc_info</span><br><span class="line">c0c70dfc t __v7_ca8_proc_info</span><br><span class="line">c0c70e30 t __v7_cr7mp_proc_info</span><br><span class="line">c0c70e64 t __v7_cr8mp_proc_info</span><br><span class="line">c0c70e98 t __v7_ca7mp_proc_info</span><br><span class="line">c0c70ecc t __v7_ca12mp_proc_info</span><br><span class="line">c0c70f00 t __v7_ca15mp_proc_info</span><br><span class="line">c0c70f34 t __v7_b15mp_proc_info</span><br><span class="line">c0c70f68 t __v7_ca17mp_proc_info</span><br><span class="line">c0c70f9c t __v7_ca73_proc_info</span><br><span class="line">c0c70fd0 t __v7_ca75_proc_info</span><br><span class="line">c0c71004 t __krait_proc_info</span><br><span class="line">c0c71038 t __v7_proc_info</span><br><span class="line">c0c7106c T __proc_info_end</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因为这里分析的是<code>armv7</code>体系、<code>Cortex-a7</code>架构，所以对应的<code>procinfo</code>信息保存在<code>arch/arm/mm/proc-v7.S</code>文件中，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">	.section <span class="string">&quot;.rodata&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span>	cpu_arch_name, <span class="string">&quot;armv7&quot;</span></span><br><span class="line">	<span class="built_in">string</span>	cpu_elf_name, <span class="string">&quot;v7&quot;</span></span><br><span class="line">	.align</span><br><span class="line"></span><br><span class="line">	.section <span class="string">&quot;.proc.info.init&quot;</span>, <span class="meta">#alloc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Standard v7 proc info content</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">.macro __v7_proc name, initfunc, mm_mmuflags = <span class="number">0</span>, io_mmuflags = <span class="number">0</span>, hwcaps = <span class="number">0</span>, proc_fns = v7_processor_functions, cache_fns = v7_cache_fns</span><br><span class="line">	ALT_SMP(.<span class="type">long</span>	PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \</span><br><span class="line">			PMD_SECT_AF | PMD_FLAGS_SMP | \mm_mmuflags)</span><br><span class="line">	ALT_UP(.<span class="type">long</span>	PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \</span><br><span class="line">			PMD_SECT_AF | PMD_FLAGS_UP | \mm_mmuflags)</span><br><span class="line">	.<span class="type">long</span>	PMD_TYPE_SECT | PMD_SECT_AP_WRITE | \</span><br><span class="line">		PMD_SECT_AP_READ | PMD_SECT_AF | \io_mmuflags</span><br><span class="line">	initfn	\initfunc, \name</span><br><span class="line">	.<span class="type">long</span>	cpu_arch_name</span><br><span class="line">	.<span class="type">long</span>	cpu_elf_name</span><br><span class="line">	.<span class="type">long</span>	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_FAST_MULT | \</span><br><span class="line">		HWCAP_EDSP | HWCAP_TLS | \hwcaps</span><br><span class="line">	.<span class="type">long</span>	cpu_v7_name</span><br><span class="line">	.<span class="type">long</span>	\proc_fns</span><br><span class="line">	.<span class="type">long</span>	v7wbi_tlb_fns</span><br><span class="line">	.<span class="type">long</span>	v6_user_fns</span><br><span class="line">	.<span class="type">long</span>	\cache_fns</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Match any ARMv7 processor core.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.type	__v7_proc_info, <span class="meta">#object</span></span><br><span class="line">__v7_proc_info:</span><br><span class="line">	.<span class="type">long</span>	<span class="number">0x000f0000</span>		@ Required ID value</span><br><span class="line">	.<span class="type">long</span>	<span class="number">0x000f0000</span>		@ Mask <span class="keyword">for</span> ID</span><br><span class="line">	__v7_proc __v7_proc_info, __v7_setup</span><br><span class="line">	.size	__v7_proc_info, . - __v7_proc_info</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>.long 0x000f0000</code>表示处理器ID,对应结构体的<code>cpu_val</code>；</li>
<li><code>.long 0x000f0000</code>表示处理器ID的掩码，对应结构体的<code>cpu_mask</code>；</li>
<li><code>__v7_proc __v7_proc_info, __v7_setup</code>指令将<code>__v7_proc_info</code>和<code>__v7_setup</code>作为参数传入<code>__v7_proc</code>函数，继续初始化<code>procinfo</code>后面部分成员；</li>
<li><code>.size __v7_proc_info, . - __v7_proc_info</code>指令表示<code>__v7_proc_info</code>结构体的大小为当前位置<code>.</code>减去<code>__v7_proc_info</code>标号地址；</li>
</ul>
<p>&emsp;&emsp;最终，<code>cupinfo</code>可以通过<code>__v7_proc</code>函数都初始化完成，这里有一点重要的是<code>initfn    \initfunc, \name</code>这个指令，<code>initfn</code>定义在<code>arch/arm/mm/proc-macros.S</code>文件中，如下所示，所以<code>__cpu_flush</code>变量中保存的不是<code>__v7_setup</code>的地址，而是相对于<code>procinfo</code>也就是<code>__v7_proc_info</code>标号的偏移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.macro	initfn, func, base</span><br><span class="line">	.<span class="type">long</span>	\func - \base</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></p>
<h3 id="查找处理器信息"><a href="#查找处理器信息" class="headerlink" title="查找处理器信息"></a>查找处理器信息</h3><p>&emsp;&emsp;知道内核是如何保存处理器信息的后，那么分析<code>__lookup_processor_type</code>在内核中查找对应的处理器信息就方便了，<code>__lookup_processor_type</code>函数定义在<code>arch/arm/kernel/head-common.S</code>文件中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read processor ID register (CP#15, CR0), and look up in the linker-built</span></span><br><span class="line"><span class="comment"> * supported processor list.  Note that we can&#x27;t use the absolute addresses</span></span><br><span class="line"><span class="comment"> * for the __proc_info lists since we aren&#x27;t running with the MMU on</span></span><br><span class="line"><span class="comment"> * (and therefore, we are not in the correct address space).  We have to</span></span><br><span class="line"><span class="comment"> * calculate the offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	r9 = cpuid</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *	r3, r4, r6 corrupted</span></span><br><span class="line"><span class="comment"> *	r5 = proc_info pointer in physical address space</span></span><br><span class="line"><span class="comment"> *	r9 = cpuid (preserved)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__lookup_processor_type:</span><br><span class="line">	adr	r3, __lookup_processor_type_data</span><br><span class="line">	ldmia	r3, &#123;r4 - r6&#125;</span><br><span class="line">	sub	r3, r3, r4			@ get offset between virt&amp;phys</span><br><span class="line">	add	r5, r5, r3			@ convert virt addresses to</span><br><span class="line">	add	r6, r6, r3			@ physical address space</span><br><span class="line"><span class="number">1</span>:	ldmia	r5, &#123;r3, r4&#125;			@ value, mask</span><br><span class="line">	and	r4, r4, r9			@ mask wanted bits</span><br><span class="line">	teq	r3, r4</span><br><span class="line">	beq	<span class="number">2f</span></span><br><span class="line">	add	r5, r5, #PROC_INFO_SZ		@ <span class="keyword">sizeof</span>(proc_info_list)</span><br><span class="line">	cmp	r5, r6</span><br><span class="line">	blo	<span class="number">1b</span></span><br><span class="line">	mov	r5, #<span class="number">0</span>				@ unknown processor</span><br><span class="line"><span class="number">2</span>:	ret	lr</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__lookup_processor_type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look in &lt;asm/procinfo.h&gt; for information about the __proc_info structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	.align	2</span><br><span class="line">	.type	__lookup_processor_type_data, %object</span><br><span class="line">__lookup_processor_type_data:</span><br><span class="line">	.<span class="type">long</span>	.</span><br><span class="line">	.<span class="type">long</span>	__proc_info_begin</span><br><span class="line">	.<span class="type">long</span>	__proc_info_end</span><br><span class="line">	.size	__lookup_processor_type_data, . - __lookup_processor_type_data</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>__lookup_processor_type</code>首先执行<code>adr</code>命令将<code>__lookup_processor_type_data</code>标号的地址读取到R3寄存器中，然后执行<code>ldmia    r3, &#123;r4 - r6&#125;</code>命令将R3寄存器中地址处开始的数据到R4到R6寄存器中，此时这几个寄存器中内容如下：</p>
<ul>
<li>R3寄存器中保存的是<code>__lookup_processor_type_data</code>标号的绝对地址，也就是真实的物理地址；</li>
<li>R4寄存器保存的是<code>__lookup_processor_type_data</code>标号的虚拟地址，是根据链接地址计算的；</li>
<li>R5寄存器保存的是链接脚本中<code>init.proc.info</code>段的起始地址，是虚拟地址；</li>
<li>R6寄存器保存的是链接脚本中<code>init.proc.info</code>段的结束地址，也是虚拟地址；</li>
</ul>
<p>&emsp;&emsp;通过<code>__lookup_processor_type_data</code>的2个地址计算出差值，可以计算出<code>init.proc.info</code>段的起始地址和结束地址在内存中的真实地址，此时R5寄存器保存的是<code>init.proc.info</code>中第一个<code>procinfo</code>的起始地址：</p>
<ol>
<li><code>ldmia    r5, &#123;r3, r4&#125;</code>：将第一个<code>procinfo</code>地址处的8字节读取到R3和R4寄存器中，也就是<code>procinfo</code>的处理器ID和掩码；</li>
<li><code>and    r4, r4, r9</code>：将R9寄存器(处理器ID)和R4寄存器中的掩码与运算；</li>
<li><code>teq    r3, r4</code>：将R3寄存器中的处理器ID和运算后的值比较；</li>
<li><code>beq    2f</code>：如果相同就跳转到<code>2:</code>标号处，说明找到了匹配的<code>procinfo</code>，保存到R5寄存器中；</li>
<li><code>add    r5, r5, #PROC_INFO_SZ</code>：否则将R5寄存器加一个<code>procinfo</code>的大小指向下一个<code>procinfo</code>；</li>
<li><code>cmp    r5, r6</code>：比较此时的R5寄存器中地址和R6寄存器中<code>init.proc.info</code>段的结束地址；</li>
<li><code>blo    1b</code>：如果小于结束地址则跳转到<code>1:</code>标号继续匹配；</li>
<li><code>mov    r5, #0</code>：否则将0写入R5寄存器，然后执行<code>2:</code>标号退出函数；</li>
</ol>
<h3 id="处理器相关设置"><a href="#处理器相关设置" class="headerlink" title="处理器相关设置"></a>处理器相关设置</h3><p>&emsp;&emsp;前面分析处理器的设置函数为<code>procinfo</code>中<code>__cpu_flush</code>成员计算的，也就是<code>__v7_setup</code>函数，该符号定义在<code>arch/arm/mm/proc-v7.S</code>文件中如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">__v7_setup:</span><br><span class="line">	adr	r0, __v7_setup_stack_ptr</span><br><span class="line">	ldr	r12, [r0]</span><br><span class="line">	add	r12, r12, r0			@ the local <span class="built_in">stack</span></span><br><span class="line">	stmia	r12, &#123;r1-r6, lr&#125;		@ v7_invalidate_l1 touches r0-r6</span><br><span class="line">	bl      v7_invalidate_l1</span><br><span class="line">	ldmia	r12, &#123;r1-r6, lr&#125;</span><br><span class="line"></span><br><span class="line">__v7_setup_cont:</span><br><span class="line">	and	r0, r9, #<span class="number">0xff000000</span>		@ ARM?</span><br><span class="line">	teq	r0, #<span class="number">0x41000000</span></span><br><span class="line">	bne	__errata_finish</span><br><span class="line">	and	r3, r9, #<span class="number">0x00f00000</span>		@ variant</span><br><span class="line">	and	r6, r9, #<span class="number">0x0000000f</span>		@ revision</span><br><span class="line">	orr	r6, r6, r3, lsr #<span class="number">20</span><span class="number">-4</span>		@ combine variant and revision</span><br><span class="line">	ubfx	r0, r9, #<span class="number">4</span>, #<span class="number">12</span>			@ primary part number</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cortex-A8 Errata */</span></span><br><span class="line">	ldr	r10, =<span class="number">0x00000c08</span>		@ Cortex-A8 primary part number</span><br><span class="line">	teq	r0, r10</span><br><span class="line">	beq	__ca8_errata</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cortex-A9 Errata */</span></span><br><span class="line">	ldr	r10, =<span class="number">0x00000c09</span>		@ Cortex-A9 primary part number</span><br><span class="line">	teq	r0, r10</span><br><span class="line">	beq	__ca9_errata</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cortex-A12 Errata */</span></span><br><span class="line">	ldr	r10, =<span class="number">0x00000c0d</span>		@ Cortex-A12 primary part number</span><br><span class="line">	teq	r0, r10</span><br><span class="line">	beq	__ca12_errata</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cortex-A17 Errata */</span></span><br><span class="line">	ldr	r10, =<span class="number">0x00000c0e</span>		@ Cortex-A17 primary part number</span><br><span class="line">	teq	r0, r10</span><br><span class="line">	beq	__ca17_errata</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cortex-A15 Errata */</span></span><br><span class="line">	ldr	r10, =<span class="number">0x00000c0f</span>		@ Cortex-A15 primary part number</span><br><span class="line">	teq	r0, r10</span><br><span class="line">	beq	__ca15_errata</span><br><span class="line"></span><br><span class="line">__errata_finish:</span><br><span class="line">	mov	r10, #<span class="number">0</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r10, c7, c5, <span class="number">0</span>		@ I+BTB cache invalidate</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r10, c8, c7, <span class="number">0</span>		@ invalidate I + D TLBs</span><br><span class="line">	v7_ttb_setup r10, r4, r5, r8, r3	@ TTBCR, TTBRx setup </span><br><span class="line">	ldr	r3, =PRRR			@ PRRR</span><br><span class="line">	ldr	r6, =NMRR			@ NMRR</span><br><span class="line">	mcr	p15, <span class="number">0</span>, r3, c10, c2, <span class="number">0</span>		@ write PRRR </span><br><span class="line">	mcr	p15, <span class="number">0</span>, r6, c10, c2, <span class="number">1</span>		@ write NMRR</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	dsb					@ Complete invalidations</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARM_THUMBEE</span></span><br><span class="line">	mrc	p15, <span class="number">0</span>, r0, c0, c1, <span class="number">0</span>		@ read ID_PFR0 <span class="keyword">for</span> ThumbEE</span><br><span class="line">	and	r0, r0, #(<span class="number">0xf</span> &lt;&lt; <span class="number">12</span>)		@ ThumbEE enabled field</span><br><span class="line">	teq	r0, #(<span class="number">1</span> &lt;&lt; <span class="number">12</span>)			@ check <span class="keyword">if</span> ThumbEE is present</span><br><span class="line">	bne	<span class="number">1f</span></span><br><span class="line">	mov	r3, #<span class="number">0</span> </span><br><span class="line">	mcr	p14, <span class="number">6</span>, r3, c1, c0, <span class="number">0</span>		@ Initialize TEEHBR to <span class="number">0</span></span><br><span class="line">	mrc	p14, <span class="number">6</span>, r0, c0, c0, <span class="number">0</span>		@ load TEECR</span><br><span class="line">	orr	r0, r0, #<span class="number">1</span>			@ <span class="built_in">set</span> the <span class="number">1</span>st bit in order to</span><br><span class="line">	mcr	p14, <span class="number">6</span>, r0, c0, c0, <span class="number">0</span>		@ stop userspace TEEHBR access</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	adr	r3, v7_crval</span><br><span class="line">	ldmia	r3, &#123;r3, r6&#125;</span><br><span class="line"> ARM_BE8(orr	r6, r6, #<span class="number">1</span> &lt;&lt; <span class="number">25</span>)		@ big-endian page tables</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SWP_EMULATE</span></span><br><span class="line">	orr     r3, r3, #(<span class="number">1</span> &lt;&lt; <span class="number">10</span>)              @ <span class="built_in">set</span> SW bit in <span class="string">&quot;clear&quot;</span></span><br><span class="line">	bic     r6, r6, #(<span class="number">1</span> &lt;&lt; <span class="number">10</span>)              @ clear it in <span class="string">&quot;mmuset&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   	mrc	p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>		@ read control <span class="keyword">register</span></span><br><span class="line">	bic	r0, r0, r3			@ clear bits them</span><br><span class="line">	orr	r0, r0, r6			@ <span class="built_in">set</span> them</span><br><span class="line"> THUMB(	orr	r0, r0, #<span class="number">1</span> &lt;&lt; <span class="number">30</span>	)	@ Thumb exceptions</span><br><span class="line">	ret	lr				@ <span class="keyword">return</span> to head.S:__ret</span><br><span class="line"></span><br><span class="line">	.align	<span class="number">2</span></span><br><span class="line">__v7_setup_stack_ptr:</span><br><span class="line">	.word	PHYS_RELATIVE(__v7_setup_stack, .)</span><br><span class="line">ENDPROC(__v7_setup)</span><br><span class="line"></span><br><span class="line">	.bss</span><br><span class="line">	.align	<span class="number">2</span></span><br><span class="line">__v7_setup_stack:</span><br><span class="line">	.space	<span class="number">4</span> * <span class="number">7</span>				@ <span class="number">7</span> registers</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>__v7_setup</code>函数执行的第一段代码是<code>adr    r0, __v7_setup_stack_ptr</code>，将<code>__v7_setup_stack_ptr</code>符号的地址读取到R0寄存器中(内核启动时R0寄存器为0，没有做特殊用途)，该地址处指令为<code>.word    PHYS_RELATIVE(__v7_setup_stack, .)</code>，这段代码表示该地址保存的是一个<code>word</code>，将宏展开后其实该地址保存的就是<code>__v7_setup_stack</code>标号到<code>__v7_setup_stack_ptr</code>标号的偏移值。接着执行<code>ldr r12, [r0]</code>将该地址处的偏移值读取到R12寄存器中，然后执行<code>add r12, r12, r0</code>将R12和R0寄存器中的值相加。所以前面三行代码实际上就是将<code>__v7_setup_stack</code>标号的地址读取到R12寄存器，<code>__v7_setup_stack</code>标号处<code>.space 4 * 7</code>则是申请7给4字节的栈；了解前面三行代码后后面3行就好理解了，将R1寄存器到R6寄存器以及LR寄存器这7个寄存器的值保存到栈中执行完<code>v7_invalidate_l1</code>函数后再取出来。<code>v7_invalidate_l1</code>标号定义在<code>arch/arm/mm/cache-v7.S</code>文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The secondary kernel init calls v7_flush_dcache_all before it enables</span></span><br><span class="line"><span class="comment"> * the L1; however, the L1 comes out of reset in an undefined state, so</span></span><br><span class="line"><span class="comment"> * the clean + invalidate performed by v7_flush_dcache_all causes a bunch</span></span><br><span class="line"><span class="comment"> * of cache lines with uninitialized data and uninitialized tags to get</span></span><br><span class="line"><span class="comment"> * written out to memory, which does really unpleasant things to the main</span></span><br><span class="line"><span class="comment"> * processor.  We fix this by performing an invalidate, rather than a</span></span><br><span class="line"><span class="comment"> * clean + invalidate, before jumping into the kernel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is cloned from arch/arm/mach-tegra/headsmp.S, and needs</span></span><br><span class="line"><span class="comment"> * to be called for both secondary cores startup and primary core resume</span></span><br><span class="line"><span class="comment"> * procedures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ENTRY(v7_invalidate_l1)</span><br><span class="line">       mov     r0, #<span class="number">0</span></span><br><span class="line">       <span class="comment">/* CSSELR,高速缓存大小选择寄存器、VMSA</span></span><br><span class="line"><span class="comment">        * bit[31:4] 保留</span></span><br><span class="line"><span class="comment">        * bit[3:1]  所需缓存级别，表示一级的0b000到7级的0b110</span></span><br><span class="line"><span class="comment">        * bit[0]    指令而不是数据位，0表示数据或统一缓存，1表示指令高速缓存</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       mcr     p15, <span class="number">2</span>, r0, c0, c0, <span class="number">0</span></span><br><span class="line">       <span class="comment">/* CCSIDR、高速缓存大小ID寄存器、VMSA</span></span><br><span class="line"><span class="comment">        * bit[27:13] (缓存中的集合数，NumSets)- 1，因此0的值表示缓存中的1个集合。集合数不一定是2的幂</span></span><br><span class="line"><span class="comment">        * bit[3:12] (缓存的关联性，Associativity)-1，因此，值0表示关联性为1。关联性不一定是2的幂。</span></span><br><span class="line"><span class="comment">        * bit[2:0] (Log2(高速缓存线中的字数))-2。例如：</span></span><br><span class="line"><span class="comment">        *     对于4个字的行长：Log2(4)=2，LineSize Entry=0。这是最小线路长度。</span></span><br><span class="line"><span class="comment">        *    对于8个字的行长：Log2(8)=3，LineSize Entry=1。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       mrc     p15, <span class="number">1</span>, r0, c0, c0, <span class="number">0</span></span><br><span class="line">       <span class="comment">/* 读取0x7fff到r1寄存器 */</span></span><br><span class="line">       movw    r1, #<span class="number">0x7fff</span></span><br><span class="line">       <span class="comment">/* 将0x7fff与CCSIDR读取的值右移动13位相与，也就是获取</span></span><br><span class="line"><span class="comment">        * 该寄存器中bit[27:13]  (这里27-13是15位但是2字节是16位)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       and     r2, r1, r0, lsr #<span class="number">13</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 写入0x3fff到r1，这里0x3fff是14位 */</span></span><br><span class="line">       movw    r1, #<span class="number">0x3ff</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">/* r0左移3位并与上0x3fff，这里bit[12:3]是10位，但是0x3fff是14位 */</span></span><br><span class="line">       and     r3, r1, r0, lsr #<span class="number">3</span>      @ NumWays - <span class="number">1</span></span><br><span class="line">       <span class="comment">/* 从bit[27：13]获取的值也就是NumSet加1 */</span></span><br><span class="line">       add     r2, r2, #<span class="number">1</span>              @ NumSets</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 获取r0的最低3位 */</span></span><br><span class="line">       and     r0, r0, #<span class="number">0x7</span></span><br><span class="line">       <span class="comment">/* 然后再加4 */</span></span><br><span class="line">       add     r0, r0, #<span class="number">4</span>      @ SetShift</span><br><span class="line">      </span><br><span class="line">       <span class="comment">/* 这里是计算r3也就是bit[12:3]中从最31位开始往地位计算0的个数，</span></span><br><span class="line"><span class="comment">        * 例如 0000 0000 0000 1000 0000 0000 0000 0000 计算出来就是12</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       clz     r1, r3          @ WayShift</span><br><span class="line">       add     r4, r3, #<span class="number">1</span>      @ NumWays</span><br><span class="line"><span class="number">1</span>:     sub     r2, r2, #<span class="number">1</span>      @ NumSets--</span><br><span class="line">       mov     r3, r4          @ Temp = NumWays</span><br><span class="line"><span class="number">2</span>:     subs    r3, r3, #<span class="number">1</span>      @ Temp--</span><br><span class="line">       mov     r5, r3, lsl r1</span><br><span class="line">       mov     r6, r2, lsl r0</span><br><span class="line">       orr     r5, r5, r6      @ Reg = (Temp&lt;&lt;WayShift)|(NumSets&lt;&lt;SetShift)</span><br><span class="line">       mcr     p15, <span class="number">0</span>, r5, c7, c6, <span class="number">2</span></span><br><span class="line">       bgt     <span class="number">2b</span></span><br><span class="line">       cmp     r2, #<span class="number">0</span></span><br><span class="line">       bgt     <span class="number">1b</span></span><br><span class="line">       dsb     st</span><br><span class="line">       isb</span><br><span class="line">       ret     lr</span><br><span class="line">ENDPROC(v7_invalidate_l1)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面<code>1f</code>标号处代码大概这个意思，没仔细研究：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NumWays(r4) = xxx</span><br><span class="line">NumSets(r2) = yyy</span><br><span class="line">SetShift(r0) = NumSets + <span class="number">4</span></span><br><span class="line">WayShift(r1) = clz(NumWays)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(--NumSets)</span><br><span class="line">&#123;</span><br><span class="line">    Temp = NumWays;</span><br><span class="line">    <span class="keyword">while</span> (--Temp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Temp == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r5 = Temp &lt;&lt; WayShift | NumSets &lt;&lt; NumWays;</span><br><span class="line">            <span class="comment">/* 写寄存器，这个寄存器没找到对应的说明 */</span></span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;执行完<code>v7_invalidate_l1</code>后回到<code>__v7_setup</code>，因为该标号没有返回，所以继续执行<code>__v7_setup_cont</code>，这里首先执行<code>and    r0, r9, #0xff000000</code>指令获取R9寄存器也就是处理器ID的最高1字节到R0寄存器中，然后执行<code>teq    r0, #0x41000000</code>将其与<code>0x41000000</code>比较，前面分析该处理器的ID为<code>0x000f0000</code>，所以条件不成立，<code>bne __errata_finish</code>指令则直接跳转到<code>__errata_finish</code>标号，这里先分析前面部分，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__errata_finish:</span><br><span class="line">	mov	r10, #<span class="number">0</span></span><br><span class="line">	<span class="comment">/* 指令cache使无效 */</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r10, c7, c5, <span class="number">0</span>		@ I+BTB cache invalidate</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="comment">/* 对整个TLB使无效 */</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r10, c8, c7, <span class="number">0</span>		@ invalidate I + D TLBs</span><br><span class="line">	v7_ttb_setup r10, r4, r5, r8, r3	@ TTBCR, TTBRx setup </span><br><span class="line">	ldr	r3, =PRRR			@ PRRR</span><br><span class="line">	ldr	r6, =NMRR			@ NMRR</span><br><span class="line">	mcr	p15, <span class="number">0</span>, r3, c10, c2, <span class="number">0</span>		@ write PRRR </span><br><span class="line">	mcr	p15, <span class="number">0</span>, r6, c10, c2, <span class="number">1</span>		@ write NMRR</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 数据同步隔离，只有前面指令执行完才能继续往下走 */</span></span><br><span class="line">	dsb					@ Complete invalidations</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码首先对指令Cache进行使无效操作，如果定义了<code>CONFIG_MMU</code>则继续对整个TLB使无效操作，执行了<code>v7_ttb_setup</code>操作，这个标号定义在<code>arch/arm/mm/proc-v7-2level.S</code>文件中(也有可能在<code>proc-v7-2level.S</code>，根据前面宏定义选择是哪个文件)。<code>v7_ttb_setup</code>主要<code>TTBCR</code>寄存器操作了，该寄存器是虚拟内存控制寄存器功能组的一部分，这里不做具体分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Macro for setting up the TTBRx and TTBCR registers.</span></span><br><span class="line"><span class="comment">	* - \ttb0 and \ttb1 updated with the corresponding flags.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">.macro	v7_ttb_setup, zero, ttbr0l, ttbr0h, ttbr1, tmp</span><br><span class="line">mcr	p15, <span class="number">0</span>, \zero, c2, c0, <span class="number">2</span>	@ TTB control <span class="keyword">register</span></span><br><span class="line"><span class="title function_">ALT_SMP</span><span class="params">(orr	\ttbr0l, \ttbr0l, #TTB_FLAGS_SMP)</span></span><br><span class="line"><span class="title function_">ALT_UP</span><span class="params">(orr	\ttbr0l, \ttbr0l, #TTB_FLAGS_UP)</span></span><br><span class="line"><span class="title function_">ALT_SMP</span><span class="params">(orr	\ttbr1, \ttbr1, #TTB_FLAGS_SMP)</span></span><br><span class="line"><span class="title function_">ALT_UP</span><span class="params">(orr	\ttbr1, \ttbr1, #TTB_FLAGS_UP)</span></span><br><span class="line">mcr	p15, 0, \ttbr1, c2, c0, 1	@ load TTB1</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;操作完TTBCR寄存器后又对PRRR(主区域重映射寄存器)和NMRR(正常内存重新映射寄存器)两个寄存器进行设置。PRRR控制TeX[0]、C和B存储器区域属性的顶级映射，NMRR为通过其在PRRR中的条目映射为正常存储器的存储器区域提供额外的映射控制，这两个寄存器都是虚拟内存控制器功能组的一部分。接下来分析<code>__errata_finish</code>标号的中间部分，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARM_THUMBEE</span></span><br><span class="line">	<span class="comment">/*  读取ID_PFR0寄存器，提供有关程序员模型的信息和有关处理器支持的指令集的顶级信息。 */</span></span><br><span class="line">	mrc	p15, <span class="number">0</span>, r0, c0, c1, <span class="number">0</span>		@ read ID_PFR0 <span class="keyword">for</span> ThumbEE</span><br><span class="line">	<span class="comment">/* 获取12到15bit，值为0b0000表示未实施ThumbEE，0b0001表示已实施 */</span></span><br><span class="line">	and	r0, r0, #(<span class="number">0xf</span> &lt;&lt; <span class="number">12</span>)		@ ThumbEE enabled field</span><br><span class="line">	<span class="comment">/* 比较是否等于1 */</span></span><br><span class="line">	teq	r0, #(<span class="number">1</span> &lt;&lt; <span class="number">12</span>)			@ check <span class="keyword">if</span> ThumbEE is present</span><br><span class="line">	<span class="comment">/* 如果条件成立，则跳转到标号1 */</span></span><br><span class="line">	bne	<span class="number">1f</span></span><br><span class="line">	<span class="comment">/* 否则对r3寄存器清零 */</span></span><br><span class="line">	mov	r3, #<span class="number">0</span></span><br><span class="line">	<span class="comment">/* TEEHBR寄存器保存ThumbEE处理程序的基址 */</span></span><br><span class="line">	mcr	p14, <span class="number">6</span>, r3, c1, c0, <span class="number">0</span>		@ Initialize TEEHBR to <span class="number">0</span></span><br><span class="line">	<span class="comment">/* 该寄存器是ThumbEE寄存器，控制对TEEHBR的非特权访问 */</span></span><br><span class="line">	mrc	p14, <span class="number">6</span>, r0, c0, c0, <span class="number">0</span>		@ load TEECR</span><br><span class="line">	<span class="comment">/* 对bit1置1，表示禁用非特权访问 */</span></span><br><span class="line">	orr	r0, r0, #<span class="number">1</span>			@ <span class="built_in">set</span> the <span class="number">1</span>st bit in order to</span><br><span class="line">	<span class="comment">/* 写入寄存器 */</span></span><br><span class="line">	mcr	p14, <span class="number">6</span>, r0, c0, c0, <span class="number">0</span>		@ stop userspace TEEHBR access</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;ThumbEE也就是所谓的Thumb-2EE，专为一些语言如Limbo、Java、C#、Perl和Python，并能让即时编译器能够输出更小的编译码却不会影响到效能，如果内核不支持<code>CONFIG_ARM_THUMBEE</code>，需要对相关寄存器进行操作。接着分析<code>__errata_finish</code>最后一部分，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	adr	r3, v7_crval</span><br><span class="line">	ldmia	r3, &#123;r3, r6&#125;</span><br><span class="line"> ARM_BE8(orr	r6, r6, #<span class="number">1</span> &lt;&lt; <span class="number">25</span>)		@ big-endian page tables</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SWP_EMULATE</span></span><br><span class="line">	orr     r3, r3, #(<span class="number">1</span> &lt;&lt; <span class="number">10</span>)              @ <span class="built_in">set</span> SW bit in <span class="string">&quot;clear&quot;</span></span><br><span class="line">	bic     r6, r6, #(<span class="number">1</span> &lt;&lt; <span class="number">10</span>)              @ clear it in <span class="string">&quot;mmuset&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   	mrc	p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>		@ read control <span class="keyword">register</span></span><br><span class="line">	bic	r0, r0, r3			@ clear bits them</span><br><span class="line">	orr	r0, r0, r6			@ <span class="built_in">set</span> them</span><br><span class="line"> <span class="title function_">THUMB</span><span class="params">(	orr	r0, r0, #<span class="number">1</span> &lt;&lt; <span class="number">30</span>	)</span>	@ Thumb exceptions</span><br><span class="line">	ret	lr				@ <span class="keyword">return</span> to head.S:__ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第一条指令将<code>v7_crval</code>标号的地址读取到R3寄存器，该标号定义在<code>arch/arm/mm/proc-v7-2level.S</code>文件中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*   AT</span></span><br><span class="line"><span class="comment">	 *  TFR   EV X F   I D LR    S</span></span><br><span class="line"><span class="comment">	 * .EEE ..EE PUI. .T.T 4RVI ZWRS BLDP WCAM</span></span><br><span class="line"><span class="comment">	 * rxxx rrxx xxx0 0101 xxxx xxxx x111 xxxx &lt; forced</span></span><br><span class="line"><span class="comment">	 *   01    0 110       0011 1100 .111 1101 &lt; we want</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.align	<span class="number">2</span></span><br><span class="line">	.type	v7_crval, <span class="meta">#object</span></span><br><span class="line">v7_crval:</span><br><span class="line">	crval	clear=<span class="number">0x2120c302</span>, mmuset=<span class="number">0x10c03c7d</span>, ucset=<span class="number">0x00c01c7c</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的<code>crval</code>是一个宏指令，如果定义了<code>CONFIG_MMU</code>宏，这里<code>v7_crval</code>标号处就是<code>clear</code>和<code>mmuset</code>这两个变量；该宏指令定义在<code>arch/arm/mm/proc-macros.S</code>文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.macro	crval, clear, mmuset, ucset</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	.word	\clear</span><br><span class="line">	.word	\mmuset</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	.word	\clear</span><br><span class="line">	.word	\ucset</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;继续前面分析，将<code>v7_crval</code>标号读取到R3寄存器中，<code>ldmia    r3, &#123;r3, r6&#125;</code>指令将这2个变量读取到R3和R6寄存器中，通过前后代码分析，可以知道这部分代码是要从CP15协处理器中读取SCTLR寄存器的值，然后对<code>clear</code>进行对指定的位清零，最后用mmuset对其进行设置。SCTLR寄存器提供系统的顶层控制，包括其存储系统，该寄存器是MMU控制寄存器功能组的一部分。这里对前面设置部分做简要分析：</p>
<ul>
<li>bit25(EE)：异常字节序比特，此位定义进入异常向量时CPSR.E位的值，包括重置。这是一个读/写位。一种实现可以包括确定EE位的复位值的配置输入信号。如果实现不包括用于此目的的配置信号，则该位将重置为零，定义了<code>CONFIG_CPU_ENDIAN_BE8</code>则bit25置1，表示大端表示法。</li>
<li>bit10(SW)：SWP/SWPB使能位。此位启用SWP和SWPB指令，作为多处理扩展的一部分添加的。如果定义了<code>CONFIG_SWP_EMULATE</code>则bit10置0，表示SWP和SWPB未定义。</li>
<li>bit30(TE)：启用Thumb异常。如果定义了<code>CONFIG_THUMB2_KERNEL</code>则bit30置1，异常和重置在Thumb状态下进行，否则在ARM指令状态下进行。</li>
</ul>
<p>&emsp;&emsp;最后设置完的值保存到R0寄存器，返回到LR寄存器指定的地址，也就是<code>stext</code>中<code>1f</code>标号的位置，该标号执行的是<code>__enable_mmu</code>标号，至此<code>__v7_setup</code>标号分析完毕。</p>
<h2 id="创建页表"><a href="#创建页表" class="headerlink" title="创建页表"></a>创建页表</h2><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>&emsp;&emsp;MMU是Memory Management Unit的缩写，中文名称是内存管理单元，它是中央处理器中用来管理虚拟存储器、物理存储器的控制线路，其功能如下：</p>
<ul>
<li>将线性地址(虚拟地址)映射成物理地址(RAM地址)</li>
<li>提供硬件机制的内存访问授权</li>
</ul>
<p>&emsp;&emsp;在linux内核中，ARM架构内核启动前期创建页表时使用的页表类型是二级页表(Level 2 Translation Tble)。此时MMU还没有启用，因此所有的地址都是物理地址，内核会根据系统物理内存的大小和分布情况创建一个大小为16KB的二级页表，用来表示整个物理地址空间。<br>&emsp;&emsp;这里使用的是段式页表，将4GB的地址空间(32位系统)划分位4096个1MB的段，故段式页表有4096个页表项，而每个页表项有32bit表示，所以对应前面所说的16KB的空间；页表项的格式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>位号</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>bit[31:20]</td>
<td>段序号</td>
</tr>
<tr>
<td>bit[19:0]</td>
<td>MMU Flag</td>
</tr>
</tbody>
</table>
</div>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>&emsp;&emsp;创建临时内核页表是内核启动时主要的一项工作，其目的是为了打开MMU功能。前面分析过相关函数是<code>__create_page_tables</code>标号，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_XIP_KERNEL</span></span><br><span class="line">	adr	r3, <span class="number">2f</span></span><br><span class="line">	ldmia	r3, &#123;r4, r8&#125;</span><br><span class="line">	sub	r4, r3, r4			@ (PHYS_OFFSET - PAGE_OFFSET)</span><br><span class="line">	add	r8, r8, r4			@ PHYS_OFFSET</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this <span class="keyword">case</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * r1 = machine no, r2 = atags or dtb,</span></span><br><span class="line"><span class="comment">	 * r8 = phys_offset, r9 = cpuid, r10 = procinfo</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	bl	__create_page_tables</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">ENDPROC(stext)</span><br><span class="line">	.ltorg</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_XIP_KERNEL</span></span><br><span class="line"><span class="number">2</span>:	.<span class="type">long</span>	.</span><br><span class="line">	.<span class="type">long</span>	PAGE_OFFSET</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里分析<code>CONFIG_XIP_KERNEL</code>未定义的情况，这里<code>2:</code>标号处保存了标号的当前相对链接地址和内存镜像开始的虚拟地址，<code>adr    r3, 2f</code>命令将标号处的地址读取到R3寄存器中，此时R3寄存器保存<code>2:</code>标号的位置，R8保存<code>PAGE_OFFSET</code>的值，这个值是内核空间映射的起始地址，保存在<code>arch/arm/include/asm/memory.h</code>文件中，最终可以在<code>include/genated/autoconf.h</code>文件中找到对应的值<code>0xC0000000</code>；接下来执行<code>sub     r4, r3, r4</code>和<code>add    r8, r8, r4</code>，因为DRAM起始地址和内核空间映射地址一样，所以这里R3和R4中的值应该是一样的，计算出来R4值是0，最后加上<code>0xC0000000</code>，R8寄存器中的值为<code>0xC0000000</code>。</p>
<p>&emsp;&emsp;计算完物理地址后就进入<code>__create_page_tables</code>标号创建页表，内容如下(这里对代码进行简化，没用到的省略了)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">__create_page_tables:</span><br><span class="line">	pgtbl	r4, r8				@ page table address</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear the swapper page table</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov	r0, r4</span><br><span class="line">	mov	r3, #<span class="number">0</span></span><br><span class="line">	add	r6, r0, #PG_DIR_SIZE</span><br><span class="line"><span class="number">1</span>:	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	teq	r0, r6</span><br><span class="line">	bne	<span class="number">1b</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_LPAE</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ldr	r7, [r10, #PROCINFO_MM_MMUFLAGS] @ mm_mmuflags</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create identity mapping to cater for __enable_mmu.</span></span><br><span class="line"><span class="comment">	 * This identity mapping will be removed by paging_init().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adr	r0, __turn_mmu_on_loc</span><br><span class="line">	ldmia	r0, &#123;r3, r5, r6&#125;</span><br><span class="line">	sub	r0, r0, r3			@ virt-&gt;phys offset</span><br><span class="line">	add	r5, r5, r0			@ phys __turn_mmu_on</span><br><span class="line">	add	r6, r6, r0			@ phys __turn_mmu_on_end</span><br><span class="line">	mov	r5, r5, lsr #SECTION_SHIFT</span><br><span class="line">	mov	r6, r6, lsr #SECTION_SHIFT</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:	orr	r3, r7, r5, lsl #SECTION_SHIFT	@ flags + kernel base</span><br><span class="line">	str	r3, [r4, r5, lsl #PMD_ORDER]	@ identity mapping</span><br><span class="line">	cmp	r5, r6</span><br><span class="line">	addlo	r5, r5, #<span class="number">1</span>			@ next section</span><br><span class="line">	blo	<span class="number">1b</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Map our RAM from the start to the end of the kernel .bss section.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	add	r0, r4, #PAGE_OFFSET &gt;&gt; (SECTION_SHIFT - PMD_ORDER)</span><br><span class="line">	ldr	r6, =(_end - <span class="number">1</span>)</span><br><span class="line">	orr	r3, r8, r7</span><br><span class="line">	add	r6, r4, r6, lsr #(SECTION_SHIFT - PMD_ORDER)</span><br><span class="line"><span class="number">1</span>:	str	r3, [r0], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">	add	r3, r3, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">	cmp	r0, r6</span><br><span class="line">	bls	<span class="number">1b</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_XIP_KERNEL</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Then map boot params address in r2 if specified.</span></span><br><span class="line"><span class="comment">	 * We map 2 sections in case the ATAGs/DTB crosses a section boundary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov	r0, r2, lsr #SECTION_SHIFT</span><br><span class="line">	movs	r0, r0, lsl #SECTION_SHIFT</span><br><span class="line">	subne	r3, r0, r8</span><br><span class="line">	addne	r3, r3, #PAGE_OFFSET</span><br><span class="line">	addne	r3, r4, r3, lsr #(SECTION_SHIFT - PMD_ORDER)</span><br><span class="line">	orrne	r6, r7, r0</span><br><span class="line">	strne	r6, [r3], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">	addne	r6, r6, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">	strne	r6, [r3]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARM_LPAE) &amp;&amp; defined(CONFIG_CPU_ENDIAN_BE8)</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LL</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_LPAE</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	ret	lr</span><br><span class="line">ENDPROC(__create_page_tables)</span><br></pre></td></tr></table></figure>
<h4 id="页表清空"><a href="#页表清空" class="headerlink" title="页表清空"></a>页表清空</h4><p>&emsp;&emsp;首先分析<code>pgtbl</code>这个宏指令，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.macro	pgtbl, rd, phys</span><br><span class="line">add	\rd, \phys, #TEXT_OFFSET</span><br><span class="line">sub	\rd, \rd, #PG_DIR_SIZE</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里用到了2个宏<code>TEXT_OFFSET</code>和<code>PG_DIR_SIZE</code>这2个宏，其中<code>TEXT_OFFSET</code>可以在<code>arch/arm/Makeile</code>中找到，如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Text offset. This list is sorted numerically by address in order to</span></span><br><span class="line"><span class="comment"># provide a means to avoid/resolve conflicts in multi-arch kernels.</span></span><br><span class="line">textofs-y	:= 0x00008000</span><br><span class="line"></span><br><span class="line"><span class="comment"># The byte offset of the kernel image in RAM from the start of RAM.</span></span><br><span class="line">TEXT_OFFSET := $(textofs-y)</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在编译时会通过<code>-DTEXT_OFFSET</code>选项指定，而<code>PG_DIR_SIZE</code>这个宏定义在<code>head.S</code>文件中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_LPAE</span></span><br><span class="line">	<span class="comment">/* LPAE requires an additional page for the PGD */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_DIR_SIZE	0x5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_ORDER	3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_DIR_SIZE	0x4000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_ORDER	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以<code>pgtbl    r4, r8</code>指令相当于<code>R4 = R8 + TEXT_OFFSET - PG_DIR_SIZE = 0xC0004000</code>，这里地址就是页表的物理地址；接下来执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear the swapper page table</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov	r0, r4</span><br><span class="line">	mov	r3, #<span class="number">0</span></span><br><span class="line">	add	r6, r0, #PG_DIR_SIZE</span><br><span class="line"><span class="number">1</span>:	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	teq	r0, r6</span><br><span class="line">	bne	<span class="number">1b</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这部分是对页表进行清零操作，每16个字节操作一次，知道R0寄存器中的值等于页表结束的地址；接下来执行<code>ldr    r7, [r10, #PROCINFO_MM_MMUFLAGS]</code>指令将之前分析<code>procinfo</code>中的<code>mm_flags</code>成员读取到R7寄存器中，<code>PROCINFO_MM_MMUFLAGS</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE(PROCINFO_MM_MMUFLAGS,    offsetof(<span class="keyword">struct</span> proc_info_list, __cpu_mm_mmu_flags));</span><br></pre></td></tr></table></figure>
<h4 id="MMU使能代码映射"><a href="#MMU使能代码映射" class="headerlink" title="MMU使能代码映射"></a>MMU使能代码映射</h4><p>&emsp;&emsp;这里接着分析<code>__create_page_tables</code>标号的下一部分，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create identity mapping to cater for __enable_mmu.</span></span><br><span class="line"><span class="comment">	 * This identity mapping will be removed by paging_init().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adr	r0, __turn_mmu_on_loc</span><br><span class="line">	ldmia	r0, &#123;r3, r5, r6&#125;</span><br><span class="line">	sub	r0, r0, r3			@ virt-&gt;phys offset</span><br><span class="line">	add	r5, r5, r0			@ phys __turn_mmu_on</span><br><span class="line">	add	r6, r6, r0			@ phys __turn_mmu_on_end</span><br><span class="line">	mov	r5, r5, lsr #SECTION_SHIFT</span><br><span class="line">	mov	r6, r6, lsr #SECTION_SHIFT</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:	orr	r3, r7, r5, lsl #SECTION_SHIFT	@ flags + kernel base</span><br><span class="line">	str	r3, [r4, r5, lsl #PMD_ORDER]	@ identity mapping</span><br><span class="line">	cmp	r5, r6</span><br><span class="line">	addlo	r5, r5, #<span class="number">1</span>			@ next section</span><br><span class="line">	blo	<span class="number">1b</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将<code>__turn_mmu_on_loc</code>标号地址读取到R0寄存器中，该标号内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	.ltorg</span><br><span class="line">	.align</span><br><span class="line">__turn_mmu_on_loc:</span><br><span class="line">	.<span class="type">long</span>	.</span><br><span class="line">	.<span class="type">long</span>	__turn_mmu_on</span><br><span class="line">	.<span class="type">long</span>	__turn_mmu_on_end</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>__turn_mmu_on</code>标号是用来打开MMU的，在打开MMU前需要将这段代码映射到临时页表中，否则打开后会导致程序跑飞；这里的<code>__turn_mmu_on</code>是标号的起始位置，<code>__turn_mmu_on_end</code>是标号的结束位置。通过计算获取2个标号的物理地址保存到R5和R6寄存器中，接着执行<code>mov    r5, r5, lsr #SECTION_SHIFT;    mov    r6, r6, lsr #SECTION_SHIFT</code>获取这2个参数的段号，这里<code>SECTION_SHIFT</code>宏定义在<code>arch/arm/mm/proc-v7-2level.S</code>文件中，其值为<code>20</code>。这里查看编译生成的<code>System.map</code>文件过滤<code>__turn_mmu_on</code>文件，如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c0008138 t __turn_mmu_on_loc</span><br><span class="line">c0100000 T __turn_mmu_on</span><br><span class="line">c0100020 t __turn_mmu_on_end</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过2个标号地址，可以知道移位后R5和R6寄存器中保存的都是<code>0xC01</code>这个段号；获取到段序号后就需要对页表项进行写入，如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:	orr	r3, r7, r5, lsl #SECTION_SHIFT	@ flags + kernel base</span><br><span class="line">	str	r3, [r4, r5, lsl #PMD_ORDER]	@ identity mapping</span><br><span class="line">	cmp	r5, r6</span><br><span class="line">	addlo	r5, r5, #<span class="number">1</span>			@ next section</span><br><span class="line">	blo	<span class="number">1b</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;前面分析的R4寄存器中保存页表的起始地址<code>0xC0004000</code>，R7寄存器中保存<code>procinfo</code>的<code>mmu_flags</code>，这里对每条指令单独分析：</p>
<ul>
<li><p>这里将段序号<code>0xC01</code>左移20位与<code>mmu_flag</code>相或，获取到对应页表项的值保存到R3寄存器中；</p>
</li>
<li><p>接着执行<code>str</code>指令将R3寄存器的值写入对应的表项物理地址，这里<code>PMD_ORDER</code>值为2，和前面用到的<code>PG_DIR_SIZE</code>宏一起定义的。因为32位系统一个表项只有4字节，所以需要左移2字节(相对于乘4)，这段代码就是将R3寄存器中的值写入<code>0xC0004000 + 0xC01 * 0x4</code>地址中，也就是<code>0xC0007004</code>地址；</p>
</li>
<li><p>接着比较R5和R6寄存器的值，如果小于R6，R5加1继续回到标号<code>1:</code>映射，直到把<code>__turn_mmu_on</code>标号所有代码映射；这里因为R5和R6值相等，没有继续执行。</p>
</li>
</ul>
<h4 id="内核镜像映射"><a href="#内核镜像映射" class="headerlink" title="内核镜像映射"></a>内核镜像映射</h4><p>&emsp;&emsp;完成MMU开启函数映射后需要继续对内核进行映射，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Map our RAM from the start to the end of the kernel .bss section.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	add	r0, r4, #PAGE_OFFSET &gt;&gt; (SECTION_SHIFT - PMD_ORDER)</span><br><span class="line">	ldr	r6, =(_end - <span class="number">1</span>)</span><br><span class="line">	orr	r3, r8, r7</span><br><span class="line">	add	r6, r4, r6, lsr #(SECTION_SHIFT - PMD_ORDER)</span><br><span class="line"><span class="number">1</span>:	str	r3, [r0], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">	add	r3, r3, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">	cmp	r0, r6</span><br><span class="line">	bls	<span class="number">1b</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里<code>_end</code>标号在<code>System.map</code>中地址为<code>0xC1A5B538</code>，这部分代码分析如下：</p>
<ul>
<li><p><code>#PAGE_OFFSET &gt;&gt; (SECTION_SHIFT - PMD_ORDER)</code>中的<code>PAGE_OFFSET</code>是DRAM的起始物理地址<code>0xC0000000</code>，也是内核映射区的起始地址，这里获取的值为内核映射区页表项的起始地址相对与整个页表起始地址的偏移量，然后加上R4中的页表起始地址，所以R0寄存器中值为<code>0xC0007000</code>。</p>
</li>
<li><p>接着将<code>__end</code>标号减去1后保存到R6寄存器；</p>
</li>
<li><p>R8寄存器保存着进入<code>__create_page_tables</code>的计算的值，也就是<code>0xC0000000</code>；将R7中保存的<code>mmu_flags</code>或上R8中的地址保存到R3寄存器，就是内核映射区页表项的值。</p>
</li>
<li><p>通过R6寄存器中内核结束地址，计算相对于页表起始地址偏移的页表项地址<code>0xC0004000 + 0xC1A5B538 &gt;&gt; 18</code>，最终值为<code>0xC0007068</code></p>
</li>
<li><p>因为最后通过将R3寄存器中的页表项值写入R0寄存器中保存的地址然后R0偏移4字节，同时将R3寄存器中页表项值加上<code>1 &lt;&lt; 20</code>后继续写入，直到R0偏移到等于R6中的结束地址就完成内核的映射了。</p>
</li>
</ul>
<h4 id="设备树映射"><a href="#设备树映射" class="headerlink" title="设备树映射"></a>设备树映射</h4><p>&emsp;&emsp;页表创建的最后一部分就是完成atags或设备树的映射，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Then map boot params address in r2 if specified.</span></span><br><span class="line"><span class="comment"> * We map 2 sections in case the ATAGs/DTB crosses a section boundary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mov	r0, r2, lsr #SECTION_SHIFT</span><br><span class="line">movs	r0, r0, lsl #SECTION_SHIFT</span><br><span class="line">subne	r3, r0, r8</span><br><span class="line">addne	r3, r3, #PAGE_OFFSET</span><br><span class="line">addne	r3, r4, r3, lsr #(SECTION_SHIFT - PMD_ORDER)</span><br><span class="line">orrne	r6, r7, r0</span><br><span class="line">strne	r6, [r3], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">addne	r6, r6, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">strne	r6, [r3]</span><br><span class="line"></span><br><span class="line">ret	lr</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因为R2寄存器中保存的是atags或者设备树的地址，所以直接对该值进行右移20比特后再左移回来(相对于1Mb对齐)，并进行符号判断，如果等于0则直接退出函数，否则继续执行下面步骤：</p>
<ul>
<li><p>计算设备树物理地址相对与DRAM起始地址的偏移保存到R3寄存器中；</p>
</li>
<li><p>将偏移量加上内核空间起始地址<code>PAGE_OFFSET</code>保存到R3寄存器中；</p>
</li>
<li><p>将要映射的虚拟地址计算出对应页表项的物理地址保存到R3寄存器中；</p>
</li>
<li><p>将R0寄存器中的起始地址或上R7寄存器中的<code>mmu_flags</code>得到页表项的值保存到R6寄存器中；</p>
</li>
<li><p>R6寄存器中页表项的值写到R3寄存器中保存的页表项的物理地址中，同时R3寄存器偏移4字节指向下一个段；</p>
</li>
<li><p>R6寄存器加上<code>1 &lt;&lt; 20</code>得到下一个段的页表项的值；</p>
</li>
<li><p>将R6中的值写到R3寄存器保存的地址中；</p>
</li>
</ul>
<p>&emsp;&emsp;执行完上述代码后页表的创建结束，返回到<code>stext</code>中继续执行。</p>
<h2 id="MMU使能"><a href="#MMU使能" class="headerlink" title="MMU使能"></a>MMU使能</h2><p>&emsp;&emsp;<code>stext</code>标号中，在进行CPU设置后，最后执行的就是MMU的使能，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	ldr	r13, =__mmap_switched		@ address to jump to after</span><br><span class="line">						@ mmu has been enabled</span><br><span class="line">	badr	lr, <span class="number">1f</span>				@ <span class="keyword">return</span> (PIC) address</span><br><span class="line"></span><br><span class="line">	mov	r8, r4				@ <span class="built_in">set</span> TTBR1 to swapper_pg_dir</span><br><span class="line"></span><br><span class="line">	ldr	r12, [r10, #PROCINFO_INITFUNC]</span><br><span class="line">	add	r12, r12, r10</span><br><span class="line">	ret	r12</span><br><span class="line"><span class="number">1</span>:	b	__enable_mmu</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>__enable_mmu</code>标号前对CPU操作部分设置了寄存器，最终部分寄存器的值如下所示：</p>
<ul>
<li>R0：CP15协处理器的SCTLR寄存器的值，提供系统顶层控制；</li>
<li>R1：机器ID；</li>
<li>R2：atags/dtb地址；</li>
<li>R4：TTB低4字节；</li>
<li>R5：如果定义LPAE则是TBL的高四字节，这里在<code>__enable_mmu</code>被覆盖了；</li>
<li>R9：处理器ID</li>
<li>R13：<code>__mmap_switched</code>标号的地址；</li>
</ul>
<p>&emsp;&emsp;下面分析<code>__enable_mmu</code>标号，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ALIGNMENT_TRAP) &amp;&amp; __LINUX_ARM_ARCH__ &lt; 6</span></span><br><span class="line">	orr	r0, r0, #CR_A</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	bic	r0, r0, #CR_A</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_DCACHE_DISABLE</span></span><br><span class="line">	bic	r0, r0, #CR_C</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_BPREDICT_DISABLE</span></span><br><span class="line">	bic	r0, r0, #CR_Z</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_ICACHE_DISABLE</span></span><br><span class="line">	bic	r0, r0, #CR_I</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_LPAE</span></span><br><span class="line">	mcrr	p15, <span class="number">0</span>, r4, r5, c2		@ load TTBR0</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	mov	r5, #DACR_INIT</span><br><span class="line">	mcr	p15, <span class="number">0</span>, r5, c3, c0, <span class="number">0</span>		@ load domain access <span class="keyword">register</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r4, c2, c0, <span class="number">0</span>		@ load page table pointer</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	b	__turn_mmu_on</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__enable_mmu)</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里对上述操作的寄存器简要分析：</p>
<ul>
<li><p>CR_A为bit[1]，对齐故障检查的使能位，这里条件不成立，表示对齐检查关闭；</p>
</li>
<li><p>CR_C为bit[2]，数据和统一缓存的全局启用位，为1表示启用数据和统一缓存，分析的代码没有启用宏；</p>
</li>
<li><p>CR_Z为bit[11]，该位是分支预测使能位，为1表示启用分支预测，分析的代码没有启用宏；</p>
</li>
<li><p>CR_I为bit[12]，指令Cache使能位，为1表示启用指令Cache使能，分析的代码没有启用宏；</p>
</li>
</ul>
<p>&emsp;&emsp;对CP15协处理器的SCTLR寄存器的值进行修改后，对2个寄存器进行写入：</p>
<ul>
<li>内存区域可缓存寄存器，简称DBR；</li>
<li>数据或统一可缓存寄存器，简称DCR；C2寄存器还有一个指令可缓存性寄存器，简称ICR，只有当实施包括单独的数据和指令存储器保护区域定义时，才实施ICR。</li>
</ul>
<p>&emsp;&emsp;这里设置的R5寄存器保存的<code>DACR_INIT</code>宏定义在<code>arch/arm/include/asm/domain.h</code>文件中，如下所示代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_SW_DOMAIN_PAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DACR_INIT \</span></span><br><span class="line"><span class="meta">	(domain_val(DOMAIN_USER, DOMAIN_NOACCESS) | \</span></span><br><span class="line"><span class="meta">	 domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) | \</span></span><br><span class="line"><span class="meta">	 domain_val(DOMAIN_IO, DOMAIN_CLIENT) | \</span></span><br><span class="line"><span class="meta">	 domain_val(DOMAIN_VECTORS, DOMAIN_CLIENT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DACR_INIT \</span></span><br><span class="line"><span class="meta">	(domain_val(DOMAIN_USER, DOMAIN_CLIENT) | \</span></span><br><span class="line"><span class="meta">	 domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) | \</span></span><br><span class="line"><span class="meta">	 domain_val(DOMAIN_IO, DOMAIN_CLIENT) | \</span></span><br><span class="line"><span class="meta">	 domain_val(DOMAIN_VECTORS, DOMAIN_CLIENT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;设置完2个寄存器后就是执行<code>__turn_mmu_on</code>标号了，该标号内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	.align	<span class="number">5</span></span><br><span class="line">	.pushsection	.idmap.text, <span class="string">&quot;ax&quot;</span></span><br><span class="line">ENTRY(__turn_mmu_on)</span><br><span class="line">	mov	r0, r0</span><br><span class="line">	instr_sync</span><br><span class="line">	mcr	p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>		@ write control reg</span><br><span class="line">	mrc	p15, <span class="number">0</span>, r3, c0, c0, <span class="number">0</span>		@ read id reg</span><br><span class="line">	instr_sync</span><br><span class="line">	mov	r3, r3</span><br><span class="line">	mov	r3, r13</span><br><span class="line">	ret	r3</span><br><span class="line">__turn_mmu_on_end:</span><br><span class="line">ENDPROC(__turn_mmu_on)</span><br><span class="line">	.popsection</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里最重要的部分就是写控制寄存器了，其中<code>mov</code>指令应该是相当于一个<code>nop</code>或者清空流水线的作用，而<code>inster_sync</code>宏指令用于指令同步隔离，定义在<code>arch/arm/include/asm/assembler.h</code>文件中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Instruction barrier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	.macro	instr_sync</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LINUX_ARM_ARCH__ &gt;= 7</span></span><br><span class="line">	isb</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __LINUX_ARM_ARCH__ == 6</span></span><br><span class="line">	mcr	p15, <span class="number">0</span>, r0, c7, c5, <span class="number">4</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后开启了MMU后就跳转到R13中保存的<code>__mmap_switched</code>标号执行了。</p>
<h2 id="入口函数跳转"><a href="#入口函数跳转" class="headerlink" title="入口函数跳转"></a>入口函数跳转</h2><p>&emsp;&emsp;<code>__mmap_siwtched</code>标号是MMU使能后在MMU模式下执行的第一段代码，并使用绝对地址，与位置无关。该标号定义在<code>arch/arm/kernel/head-common.S</code>文件中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	__INIT</span><br><span class="line">__mmap_switched:</span><br><span class="line"></span><br><span class="line">	mov	r7, r1</span><br><span class="line">	mov	r8, r2</span><br><span class="line">	mov	r10, r0</span><br><span class="line"></span><br><span class="line">	adr	r4, __mmap_switched_data</span><br><span class="line">	mov	fp, #<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_XIP_DEFLATED_DATA)</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_XIP_KERNEL)</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   ARM(	ldmia	r4!, &#123;r0, r1, sp&#125; )</span><br><span class="line"> THUMB(	ldmia	r4!, &#123;r0, r1, r3&#125; )</span><br><span class="line"> THUMB(	mov	sp, r3 )</span><br><span class="line">	sub	r2, r1, r0</span><br><span class="line">	mov	r1, #<span class="number">0</span></span><br><span class="line">	bl	<span class="built_in">memset</span>				@ clear .bss</span><br><span class="line"></span><br><span class="line">	ldmia	r4, &#123;r0, r1, r2, r3&#125;</span><br><span class="line">	str	r9, [r0]			@ Save processor ID</span><br><span class="line">	str	r7, [r1]			@ Save machine type</span><br><span class="line">	str	r8, [r2]			@ Save atags pointer</span><br><span class="line">	cmp	r3, #<span class="number">0</span></span><br><span class="line">	strne	r10, [r3]			@ Save control <span class="keyword">register</span> values</span><br><span class="line">	mov	lr, #<span class="number">0</span></span><br><span class="line">	b	start_kernel</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__mmap_switched)</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先将R0、R1和R2寄存器中的值分别保存到R10、R7和R8寄存器中，接着将<code>__mmap_switched_data</code>标号读取到R4寄存器中，并对FP寄存器进行清零；<code>__mmap_switched_data</code>标号处的数据如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	.align	<span class="number">2</span></span><br><span class="line">	.type	__mmap_switched_data, %object</span><br><span class="line">__mmap_switched_data:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_XIP_KERNEL</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.<span class="type">long</span>	__bss_start			@ r0</span><br><span class="line">	.<span class="type">long</span>	__bss_stop			@ r1</span><br><span class="line">	.<span class="type">long</span>	init_thread_union + THREAD_START_SP @ sp</span><br><span class="line">	.<span class="type">long</span>	processor_id			@ r0</span><br><span class="line">	.<span class="type">long</span>	__machine_arch_type		@ r1</span><br><span class="line">	.<span class="type">long</span>	__atags_pointer			@ r2</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_CP15</span></span><br><span class="line">	.<span class="type">long</span>	cr_alignment			@ r3</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.size	__mmap_switched_data, . - __mmap_switched_data</span><br><span class="line"></span><br><span class="line">	__FINIT</span><br><span class="line">	.text</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;清空FP寄存器后执行了<code>ARM(ldmia    r4!, &#123;r0, r1, sp&#125;)</code>命令，这个指令会将<code>__mmap_switched_data</code>前3个数据指向R0、R1和SP寄存器，同时R4寄存器中地址会偏移到第四个数据；接着就会执行<code>memset</code>清空<code>.bss</code>段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub	r2, r1, r0</span><br><span class="line">mov	r1, #<span class="number">0</span></span><br><span class="line">bl	<span class="built_in">memset</span>				@ clear .bss</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里R0为链接脚本中<code>.bss</code>段的起始地址<code>__bss_start</code>，R1为<code>.bss</code>段的结束地址<code>__bss_stop</code>，这里R2中保存的是<code>.bss</code>段的大小。清空<code>.bss</code>段后<code>ldmia    r4, &#123;r0, r1, r2, r3&#125;</code>将<code>__mmap_switched_data</code>剩下的4个值保存到R0到R3寄存器中：</p>
<ul>
<li>R0：处理器ID；</li>
<li>R1：机器架构类型；</li>
<li>R2：atags或dtb的保存地址；</li>
<li>R3：CP15中C1寄存器的值；</li>
<li>SP：当前进程的堆栈；</li>
</ul>
<p>&emsp;&emsp;因为ARM中R0到R3寄存器用于函数传参(超过4个参数用堆栈传参)，所以需要将值保存到其他地方，最终寄存器中的值为：</p>
<ul>
<li>R7：处理器ID；</li>
<li>R8：atags或dtb的保存地址；</li>
<li>R9：处理器ID；</li>
<li>R10：CP15协处理器的SCTLR寄存器的值；</li>
<li>SP：当前进程的堆栈；</li>
<li>LR：值为0</li>
</ul>
<p>&emsp;&emsp;设置完寄存器后就跳转到了Linux的入口函数<code>start_kernel</code>。</p>
<h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>&emsp;&emsp;<code>start_kernel</code>函数是linux内核启动的入口函数，该函数定义在<code>main/init.c</code>文件中，主要执行以下任务：</p>
<ul>
<li>初始化核心子系统，例如内存管理器、进程管理、文件系统等。</li>
<li>初始化硬件设备，例如中断控制器、时钟、串口等。</li>
<li>解析内核启动参数，例如命令行参数、bootloader传递的参数。</li>
<li>运行用户空间进程、例如<code>/sbin/init</code>文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *command_line;</span><br><span class="line">	<span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">	set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">	smp_setup_processor_id();</span><br><span class="line">	debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">	cgroup_init_early();</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Interrupts are still disabled. Do necessary setups, then</span></span><br><span class="line"><span class="comment">	 * enable them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	boot_cpu_init();</span><br><span class="line">	page_address_init();</span><br><span class="line">	pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);</span><br><span class="line">	early_security_init();</span><br><span class="line">	setup_arch(&amp;command_line);</span><br><span class="line">	setup_command_line(command_line);</span><br><span class="line">	setup_nr_cpu_ids();</span><br><span class="line">	setup_per_cpu_areas();</span><br><span class="line">	smp_prepare_boot_cpu();	<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line">	boot_cpu_hotplug_init();</span><br><span class="line"></span><br><span class="line">	build_all_zonelists(<span class="literal">NULL</span>);</span><br><span class="line">	page_alloc_init();</span><br><span class="line"></span><br><span class="line">	pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line);</span><br><span class="line">	<span class="comment">/* parameters may set static keys */</span></span><br><span class="line">	jump_label_init();</span><br><span class="line">	parse_early_param();</span><br><span class="line">	after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">				  static_command_line, __start___param,</span><br><span class="line">				  __stop___param - __start___param,</span><br><span class="line">				  <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, &amp;unknown_bootoption);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">		parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">			   <span class="literal">NULL</span>, set_init_arg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment">	 * kmem_cache_init()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	setup_log_buf(<span class="number">0</span>);</span><br><span class="line">	vfs_caches_init_early();</span><br><span class="line">	sort_main_extable();</span><br><span class="line">	trap_init();</span><br><span class="line">	mm_init();</span><br><span class="line"></span><br><span class="line">	ftrace_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* trace_printk can be enabled here */</span></span><br><span class="line">	early_trace_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment">	 * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment">	 * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sched_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Disable preemption - early bootup scheduling is extremely</span></span><br><span class="line"><span class="comment">	 * fragile until we cpu_idle() for the first time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line">		 <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">		local_irq_disable();</span><br><span class="line">	radix_tree_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up housekeeping before setting up workqueues to allow the unbound</span></span><br><span class="line"><span class="comment">	 * workqueue to take non-housekeeping into account.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	housekeeping_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Allow workqueue creation and work item queueing/cancelling</span></span><br><span class="line"><span class="comment">	 * early.  Work item execution depends on kthreads and starts after</span></span><br><span class="line"><span class="comment">	 * workqueue_init().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	workqueue_init_early();</span><br><span class="line"></span><br><span class="line">	rcu_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Trace events are available after this */</span></span><br><span class="line">	trace_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcall_debug)</span><br><span class="line">		initcall_debug_enable();</span><br><span class="line"></span><br><span class="line">	context_tracking_init();</span><br><span class="line">	<span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">	early_irq_init();</span><br><span class="line">	init_IRQ();</span><br><span class="line">	tick_init();</span><br><span class="line">	rcu_init_nohz();</span><br><span class="line">	init_timers();</span><br><span class="line">	hrtimers_init();</span><br><span class="line">	softirq_init();</span><br><span class="line">	timekeeping_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For best initial stack canary entropy, prepare it after:</span></span><br><span class="line"><span class="comment">	 * - setup_arch() for any UEFI RNG entropy and boot cmdline access</span></span><br><span class="line"><span class="comment">	 * - timekeeping_init() for ktime entropy used in rand_initialize()</span></span><br><span class="line"><span class="comment">	 * - rand_initialize() to get any arch-specific entropy like RDRAND</span></span><br><span class="line"><span class="comment">	 * - add_latent_entropy() to get any latent entropy</span></span><br><span class="line"><span class="comment">	 * - adding command line entropy</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rand_initialize();</span><br><span class="line">	add_latent_entropy();</span><br><span class="line">	add_device_randomness(command_line, <span class="built_in">strlen</span>(command_line));</span><br><span class="line">	boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">	time_init();</span><br><span class="line">	perf_event_init();</span><br><span class="line">	profile_init();</span><br><span class="line">	call_function_init();</span><br><span class="line">	WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment">	 * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment">	 * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (panic_later)</span><br><span class="line">		panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">		      panic_param);</span><br><span class="line"></span><br><span class="line">	lockdep_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Need to run this when irqs are enabled, because it wants</span></span><br><span class="line"><span class="comment">	 * to self-test [hard/soft]-irqs on/off lock inversion bugs</span></span><br><span class="line"><span class="comment">	 * too:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	locking_selftest();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This needs to be called before any devices perform DMA</span></span><br><span class="line"><span class="comment">	 * operations that might use the SWIOTLB bounce buffers. It will</span></span><br><span class="line"><span class="comment">	 * mark the bounce buffers as decrypted so that their usage will</span></span><br><span class="line"><span class="comment">	 * not cause &quot;plain-text&quot; data to be decrypted when accessed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mem_encrypt_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line">	<span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">	    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">		pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">		    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)),</span><br><span class="line">		    min_low_pfn);</span><br><span class="line">		initrd_start = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	setup_per_cpu_pageset();</span><br><span class="line">	numa_policy_init();</span><br><span class="line">	acpi_early_init();</span><br><span class="line">	<span class="keyword">if</span> (late_time_init)</span><br><span class="line">		late_time_init();</span><br><span class="line">	sched_clock_init();</span><br><span class="line">	calibrate_delay();</span><br><span class="line">	pid_idr_init();</span><br><span class="line">	anon_vma_init();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">	<span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">		efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	thread_stack_cache_init();</span><br><span class="line">	cred_init();</span><br><span class="line">	fork_init();</span><br><span class="line">	proc_caches_init();</span><br><span class="line">	uts_ns_init();</span><br><span class="line">	buffer_init();</span><br><span class="line">	key_init();</span><br><span class="line">	security_init();</span><br><span class="line">	dbg_late_init();</span><br><span class="line">	vfs_caches_init();</span><br><span class="line">	pagecache_init();</span><br><span class="line">	signals_init();</span><br><span class="line">	seq_file_init();</span><br><span class="line">	proc_root_init();</span><br><span class="line">	nsfs_init();</span><br><span class="line">	cpuset_init();</span><br><span class="line">	cgroup_init();</span><br><span class="line">	taskstats_init_early();</span><br><span class="line">	delayacct_init();</span><br><span class="line"></span><br><span class="line">	poking_init();</span><br><span class="line">	check_bugs();</span><br><span class="line"></span><br><span class="line">	acpi_subsystem_init();</span><br><span class="line">	arch_post_acpi_subsys_init();</span><br><span class="line">	sfi_init_late();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">	arch_call_rest_init();</span><br><span class="line"></span><br><span class="line">	prevent_tail_call_optimization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.m5xhsy.wiki">orz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.m5xhsy.wiki/77ab4a2c6cde/">https://www.m5xhsy.wiki/77ab4a2c6cde/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.m5xhsy.wiki" target="_blank">Noal</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">Linux源码阅读</a></div><div class="post_share"><div class="social-share" data-image="/statics/img/cover/default.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/32caa6b08dbc/"><img class="prev-cover" src="/statics/img/cover/tmp6.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux Tc命令流量控制</div></div></a></div><div class="next-post pull-right"><a href="/6f10d12b60ca/"><img class="next-cover" src="/statics/img/cover/default.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">高等数学</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/statics/img/core/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">orz</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/m5xhsy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:m5xhsy@163.com.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.qq.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://www.qq.com" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://m5xhsy.github.io/NoteBook/" target="_blank" title="Blog"><i class="fas fa-dove"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">额。。。就一些笔记啦&#x1F47B;</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">总览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.</span> <span class="toc-text">内核启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5SVC%E5%92%8C%E5%85%B3%E9%97%AD%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.</span> <span class="toc-text">进入SVC和关闭中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">处理器相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E4%BF%A1%E6%81%AF%E4%BF%9D%E5%AD%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">处理器信息保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%A4%84%E7%90%86%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">查找处理器信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">处理器相关设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">创建页表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">相关知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.2.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%B8%85%E7%A9%BA"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">页表清空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMU%E4%BD%BF%E8%83%BD%E4%BB%A3%E7%A0%81%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">MMU使能代码映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">内核镜像映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">设备树映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MMU%E4%BD%BF%E8%83%BD"><span class="toc-number">1.5.</span> <span class="toc-text">MMU使能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.6.</span> <span class="toc-text">入口函数跳转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">入口函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/32caa6b08dbc/" title="Linux Tc命令流量控制"><img src="/statics/img/cover/tmp6.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux Tc命令流量控制"/></a><div class="content"><a class="title" href="/32caa6b08dbc/" title="Linux Tc命令流量控制">Linux Tc命令流量控制</a><time datetime="2023-09-06T02:43:03.000Z" title="发表于 2023-09-06 10:43:03">2023-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/77ab4a2c6cde/" title="Linux源码阅读之内核启动"><img src="/statics/img/cover/default.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux源码阅读之内核启动"/></a><div class="content"><a class="title" href="/77ab4a2c6cde/" title="Linux源码阅读之内核启动">Linux源码阅读之内核启动</a><time datetime="2023-03-24T11:53:52.000Z" title="发表于 2023-03-24 19:53:52">2023-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/6f10d12b60ca/" title="高等数学"><img src="/statics/img/cover/default.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高等数学"/></a><div class="content"><a class="title" href="/6f10d12b60ca/" title="高等数学">高等数学</a><time datetime="2023-03-07T12:42:44.000Z" title="发表于 2023-03-07 20:42:44">2023-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ea63687cfc0c/" title="【无线协议基础】快速基本服务转换(80211r)"><img src="/statics/img/cover/default.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【无线协议基础】快速基本服务转换(80211r)"/></a><div class="content"><a class="title" href="/ea63687cfc0c/" title="【无线协议基础】快速基本服务转换(80211r)">【无线协议基础】快速基本服务转换(80211r)</a><time datetime="2023-02-01T13:15:54.000Z" title="发表于 2023-02-01 21:15:54">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2467c0d4b507/" title="【无线协议基础】无线网络管理(80211v)"><img src="/statics/img/cover/default.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【无线协议基础】无线网络管理(80211v)"/></a><div class="content"><a class="title" href="/2467c0d4b507/" title="【无线协议基础】无线网络管理(80211v)">【无线协议基础】无线网络管理(80211v)</a><time datetime="2023-02-01T13:15:50.000Z" title="发表于 2023-02-01 21:15:50">2023-02-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/statics/img/core/index.webp')"><div id="footer-wrap"><div class="footer_custom_text"><a href=""><img class="icp-icon" src=""><span>备案号：xxxxxx</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><div class="js-pjax"></div><script>if (window.MathJax) {window.MathJax.options.enableMenu=false;}</script><div id="right_menu"><img class="susu" src="/statics/img/core/susu.png" alt=""><div class="right_me"><ul><li onclick="right_button.selectGeneralOptions()"><span id="GeneralOptions">🍌 刷 新 一 下</span></li><li onclick="right_button.switchDarkMode()"><span id="DarkMode"></span></li><li onclick="right_button.switchReadMode()"><span id="ReadMode"></span></li><li onclick="right_button.goHome()"><span id="GoHome">🏡 回 到 主 页</span></li><li onclick="right_button.backToTop()"><span>🍈 回 到 顶 部</span></li></ul></div></div><script src="/statics/js/right-button.js"></script><canvas id="universe"></canvas><script src="/statics/js/universe.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/statics/js/canvas-nest.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>